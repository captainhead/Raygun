#pragma once

#ifndef IMAGE_BUFER
#define IMAGE_BUFER

#ifdef _WIN32
#include <Windows.h>
#endif

#include "Colour.h"
#include "TRACE.h"

////////////////////////////////////////////////////////////////////////////////
// class ImageBuffer
//
// Contains an image generated by RayTracer object
////////////////////////////////////////////////////////////////////////////////
class ImageBuffer
{
public:
	ImageBuffer(int inw, int inh)
	{
		_width = inw;
		_height = inh;
		
		buffer = new float[_width*_height*3];
	}
	~ImageBuffer(void)
	{
		delete [] buffer;
	}

	// Retrieve width and height
	inline int width() const { return _width; }
	inline int height() const { return _height; }


	// Get and set pixels as Colour objects
	// -NOTE row is inverted (rendered image is upside down), so getPixel() flips it over
	inline Colour getPixel(int row, int col) const
	{
		int i = (((_height-1)-row)*_width + col) * 3;
		return Colour(buffer[i], buffer[i+1], buffer[i+2]);
	}
	inline void setPixel(int row, int col, Colour c)
	{
		int i = (row*_width + col) * 3;
		buffer[i] = c.r();
		buffer[i+1] = c.g();
		buffer[i+2] = c.b();
	}


	// Generate rainbow static
	void rainbowStatic()
	{
		for(int row=0; row<_height; row++)
		{
			for(int col=0; col<_width; col++)
			{
				Colour out(	(float)rand()/(float)RAND_MAX,
							(float)rand()/(float)RAND_MAX,
							(float)rand()/(float)RAND_MAX);
				setPixel(row, col, out);
			}
		}
	}

private:
	float* buffer;

	int _width;
	int _height;
};

#endif